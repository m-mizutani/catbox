package models

import (
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
)

// ScanType indicates who creates the report
type ScanType string

const (
	// ScanTypeTrivy indicates that report is generated by trivy
	ScanTypeTrivy ScanType = "trivy"
)

type VulnStatus string

const (
	VulnStatusNew       = "new"
	VulnStatusIgnore    = "ignored"
	VulnStatusMitigated = "mitigated"
	VulnStatusFixed     = "fixed"
)

// VulnInfo presents Vulnerability Information (title, package name, fixed version, etc)
type VulnInfo struct {
	DBBaseRecord
	VulnID       string            `dynamo:"vuln_id" json:"vuln_id"`
	PkgType      string            `dynamo:"pkg_type" json:"pkg_type"`
	PkgName      string            `dynamo:"pkg_name" json:"pkg_name"`
	FixedVersion string            `dynamo:"fixed_version" json:"fixed_version"`
	CVSS         map[string]string `dynamo:"cvss" json:"cvss"`
	Title        string            `dynamo:"title" json:"title"`
	Description  string            `dynamo:"description" json:"description"`
}

// AssignKeys sets PK (hash key) and SK (range key) from field variables
func (x *VulnInfo) AssignKeys() {
	x.PK = "vuln_info:" + x.VulnID
	x.SK = x.PkgType + "/" + x.PkgName
}

// ScanReport presents S3 pointer of scan report
type ScanReport struct {
	DBBaseRecord        // Do not fill
	ReportID     string `dynamo:"report_id" json:"report_id"` // Do not fill

	Image

	// Scan log
	ScanType    ScanType `dynamo:"scan_type" json:"scan_type"`
	RequestedAt int64    `dynamo:"requested_at" json:"requested_at"`
	RequestedBy string   `dynamo:"requested_by" json:"requested_by"`
	InvokedAt   int64    `dynamo:"invoked_at" json:"invoked_at"`
	ScannedAt   int64    `dynamo:"scanned_at" json:"scanned_at"`

	// Output to
	S3Region string `dynamo:"s3_region" json:"s3_region"`
	S3Bucket string `dynamo:"s3_bucket" json:"s3_bucket"`
	S3Key    string `dynamo:"s3_key" json:"s3_key"`
}

func ScanReportPK(registry, repo, tag string) string {
	return fmt.Sprintf("report:%s/%s:%s", registry, repo, tag)
}
func ScanReportPK2() string {
	return "list:report"
}
func ScanReportSK2(reportID string) string {
	return reportID
}

// AssignKeys sets PK (hash key) and SK (range key) from field variables
func (x *ScanReport) AssignKeys() {
	if x.ReportID == "" {
		x.ReportID = uuid.New().String()
	}

	x.PK = ScanReportPK(x.Registry, x.Repo, x.Tag)
	x.SK = string(x.ScanType) + "/" + time.Unix(x.ScannedAt, 0).Format("2006-01-02T15:04:05") + "/" + x.ReportID
	x.PK2 = ScanReportPK2()
	x.SK2 = ScanReportSK2(x.ReportID)
}

// RepoVulnStatus presents each vulnerability status of repository by repository (registry + repository + tag).
type RepoVulnStatus struct {
	// Do not fill
	DBBaseRecord

	// Parameters required
	Image
	VulnID    string     `dynamo:"vuln_id" json:"vuln_id"`
	UpdatedAt int64      `dynamo:"updated_at" json:"updated_at"`
	Status    VulnStatus `dynamo:"status" json:"status"`
	ScanType  ScanType   `dynamo:"scan_type" json:"scan_type"`

	// Trivy based parameters
	PkgSource        string `dynamo:"pkg_source" json:"pkg_source"`
	PkgName          string `dynamo:"pkg_name" json:"pkg_name"`
	PkgType          string `dynamo:"pkg_type" json:"pkg_type"`
	InstalledVersion string `dynamo:"installed_version" json:"installed_version"`
	FixedVersion     string `dynamo:"fixed_version" json:"fixed_version"`
}

func RepoVulnStatusPK(registry, repo, tag string) string {
	img := &Image{
		Registry: registry,
		Repo:     repo,
		Tag:      tag,
	}
	return "repo_vuln_status:" + img.RegistryRepoTag()
}

func RepoVulnStatusPK2(vulnID string) string {
	return "repo_vuln_status:" + vulnID
}

// AssignKeys sets PK (hash key) and SK (range key) from field variables
func (x *RepoVulnStatus) AssignKeys() {
	timekey := time.Unix(x.UpdatedAt, 0).Format("20060102_150405")
	x.PK = RepoVulnStatusPK(x.Image.Registry, x.Image.Repo, x.Image.Tag)
	x.SK = strings.Join([]string{x.VulnID, x.PkgSource, x.PkgName, timekey}, ":")
	x.PK2 = RepoVulnStatusPK2(x.VulnID)
	x.SK2 = strings.Join([]string{x.Image.RegistryRepoTag(), x.PkgSource, x.PkgName}, ":")
}
